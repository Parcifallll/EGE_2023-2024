from itertools import combinations


# На числовой прямой даны два отрезка: D = [17; 58] и C = [29; 80].
# Укажите наименьшую возможную длину такого отрезка A, для которого логическое выражение
# (x ∈ D) → ((¬(x ∈ C) ∧ ¬(x ∈ A)) → ¬(x ∈ D))
# истинно (т.е. принимает значение 1) при любом значении переменной х.
def f(x):
    A = a1 <= x <= a2  # Отрезок А
    D = 17 <= x <= 58
    C = 29 <= x <= 80
    return D <= (((not C) and (not A)) <= (not D))  # ВСЕГДА ставим скобки, где только можно


m = []  # Собираем длины возможных отрезков А
Ox = [i / 4 for i in range((17 - 1) * 4, (80 + 1) * 4)]  # Получили числовую ось Ох с крайними координатами отрезков
# ВАЖНО: берем (17 - 1) и (80 + 1) (включаем левую и правые точки)
for a1, a2 in combinations(Ox,
                           2):  # Перебираем а1, а2. Причем, шаг = 0.25 (это решает проблему выколотой точки и разрывов на оси)
    if all(f(x) for x in Ox):
        m.append(a2 - a1)  # Записываем длины А
print(round(min(m)))  # Округление решает ошибку с выколотой точкой
# Данное решение учитывает ВСЕ нюансы 15 задания на отрезки (а также работает быстрее всех).
#Нужно обязательно соблюдать ПОРЯДОК операций!!! Инода нужно ставить скобки самому (анализировать выражение)